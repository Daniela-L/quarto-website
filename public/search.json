[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "data4health",
    "section": "",
    "text": "data4health is a tool developed as part of the HARMONIZE project to facilitate the access, preprocessing, and aggregation of health data at customized spatiotemporal resolutions. Originally designed for data from Colombia, Brazil, Peru, and the Dominican Republic, the tool is intended to be adaptable for any linelist health data.\nThe R package and offers two modes of operation based on the user’s coding experience:\n\nFor users with coding experience: A wide range of functions can be directly used within R.These functions are\nFor non-coding users: A graphical user interface (GUI) guides users through the data processing pipeline in an intuitive, user-friendly way.\n\nKey Features of the R Package:\n\nInstructions on how to access health data\nFunctions for cleaning and preprocessing health data\nSpatial harmonization, allowing aggregation to any coarser administrative unit\nTemporal harmonization, enabling aggregation to epidemiological weeks or months\nData visualization capabilities\nOutput as a .csv file, formatted to meet user-specified requirements"
  },
  {
    "objectID": "brazil.html",
    "href": "brazil.html",
    "title": "data4health",
    "section": "",
    "text": "Here you can find information about brazil.\nBrazil uses two distinct databases: SINAN and SIVEP. You can find more information about them and their differences here.",
    "crumbs": [
      "Brazil"
    ]
  },
  {
    "objectID": "peru_dengue.html",
    "href": "peru_dengue.html",
    "title": "data4health",
    "section": "",
    "text": "This will be dengu in Peru",
    "crumbs": [
      "Peru",
      "Dengue"
    ]
  },
  {
    "objectID": "brazil_SINAN_SIVEP.html",
    "href": "brazil_SINAN_SIVEP.html",
    "title": "SIVEP_SINAN",
    "section": "",
    "text": "Getting to know the Data\n\nDifferences between datasets\nFirst of all, it is important to note that, although the content of the data is always the same, the structure of data can differ depending on the selected year, on how one got the data and on when you obtain the data (since recent years can be updated retroactively after being published).\n\n# den15 &lt;- fetch_datasus(year_start = 2015, year_end = 2015, information_system = \"SINAN-DENGUE\")\n# den21 &lt;- fetch_datasus(year_start = 2021, year_end = 2021, information_system = \"SINAN-DENGUE\")\nden15 &lt;- readRDS(\"data/den15.rds\")\nden21 &lt;- readRDS(\"data/den21.rds\")\n\n\n\nDifferences between two years\nComparing the two datasets downloaded via microdatasus, from years 2015 and 2021, the first is to check whether there are different columns.\n\n# compare number of cases\nif (nrow(den21) == nrow(den15)){\n  print(\"Both datasets have the same number of cases.\")\n} else{\n  print(paste0(\"These documents have different number of cases, the 2021 dataset has \",\n               nrow(den21), \" cases, while the 2015 dataset has \",\n               nrow(den15),\" cases.\"))\n}\n\n[1] \"These documents have different number of cases, the 2021 dataset has 1010359 cases, while the 2015 dataset has 2398060 cases.\"\n\n# compare variables names\nif (identical(colnames(den15), colnames(den21))){\n  print(\"Both datsets contain the same columns.\")\n} else{\n  print(paste0(\"The columns that are different are: \",\n               paste(c(setdiff(colnames(den15), colnames(den21)),\n                       setdiff(colnames(den21), colnames(den15))), collapse=\", \")))\n}\n\n[1] \"The columns that are different are: DT_NASC, ANO_NASC, DT_DIGITA, MIGRADO_W\"\n\n# Get unique column names from both data frames\nall_columns &lt;- unique(c(names(den15), names(den21)))\n\n# Function to calculate the proportion of NA values in a column\nna_proportion &lt;- function(col) {\n  round(mean(is.na(col))*100,2)\n}\n\n# Apply the function to each column of the data frames\nden15_na &lt;- sapply(all_columns,\n                 function(col) ifelse(col %in% names(den15),\n                                      na_proportion(den15[[col]]),\n                                      NA))\nden21_na &lt;- sapply(all_columns,\n                 function(col) ifelse(col %in% names(den21),\n                                      na_proportion(den21[[col]]),\n                                      NA))\n\n# Combine the results into a new data frame\nknitr::kable(data.frame(column = all_columns, den15 = den15_na,den21 = den21_na)[24:29,])\n\n\n\n\n\ncolumn\nden15\nden21\n\n\n\n\nFEBRE\nFEBRE\n97.8\n2.22\n\n\nMIALGIA\nMIALGIA\n97.8\n2.22\n\n\nCEFALEIA\nCEFALEIA\n97.8\n2.22\n\n\nEXANTEMA\nEXANTEMA\n97.8\n2.22\n\n\nVOMITO\nVOMITO\n97.8\n2.22\n\n\nNAUSEA\nNAUSEA\n97.8\n2.22\n\n\n\n\n\nFor most variables, the amount of missing values stays similar. However, in the cases of rows 24-44, which coincide with the symptoms, it is noticeable that in 2015 all values are missing, while 98% of the cases in 2021 filled out this variable. This indicates that the variable may have not existed in 2015. It is possible to find two dengue dictionary database version around 2015. One version comes from 2010 and the other, 2015. In the first one, the symptoms variables are not there.\n\n\nDifferences between two datasets obtained differently\nAccessing data for the same year, even from the same organization, but via a different method can also lead to a different dataset. Here, the dataset was requested directly via the e-SIC platform. \nThe following code cannot be reproduced.\nThe two data sets have different number of variables, below a dataframe showcasing the variables that only appear in one of them: There are the same number of registers but differences between the variables.\nIf we compare the requested and the downloaded database for the same year?\n\n# compare number of cases\nif (nrow(den15_dbf) == nrow(den15)){\n  print(\"Both datasets have the same number of cases.\")\n} else{\n  print(paste0(\"These documents have different number of cases, the one obtained by ... has\",\n               nrow(den15_dbf), \" cases, while the dataset obtained by microdatasus has \",\n               nrow(den15),\" cases.\"))\n}\n\n# compare variables names\nif (identical(colnames(den15_dbf), colnames(den15))){\n  print(\"Both datsets contain the same columns.\")\n} else{\n  print(paste0(\"The columns that are different are: \",\n               paste(c(setdiff(colnames(den15), colnames(den15_dbf)),\n                       setdiff(colnames(den15_dbf), colnames(den15))), collapse=\", \")))\n}\n\n# Get unique column names from both data frames\nall_columns &lt;- unique(c(names(den15), names(den15_dbf)))\n\n# Function to calculate the proportion of NA values in a column\nna_proportion &lt;- function(col) {\n  round(mean(is.na(col))*100,2)\n}\n\n# Apply the function to each column of the data frames\nden15_na &lt;- sapply(all_columns,\n                 function(col) ifelse(col %in% names(den15),\n                                      na_proportion(den15[[col]]),\n                                      NA))\nden15_dbf_na &lt;- sapply(all_columns,\n                 function(col) ifelse(col %in% names(den15_dbf),\n                                      na_proportion(den15_dbf[[col]]),\n                                      NA))\n\n# Combine the results into a new data frame\nknitr::kable(data.frame(column = all_columns, den15 = den15_na,den15_dbf = den15_dbf_na)[1:10,])\n\n\n\nDifference depending on when you obtained the data\nNow, lets compare data from the same source for the same year but obtained at different moments in time.\n\ndengue21 &lt;- read.dbc(\"Data/Disease/Dengue/DENGBR21.dbc\")\ndengue21_old &lt;- read.dbc(\"Data/Disease/Dengue/DENGBR21_old.dbc\")\n\n# compare number of cases\nif (nrow(dengue21) == nrow(dengue21_old)){\n  print(\"Both datasets have the same number of cases.\")\n} else{\n  print(paste0(\"These documents have different number of cases, the new 2021 dataset has \",\n               nrow(dengue21), \" cases, while the old 2021 dataset has \",\n               nrow(dengue21_old),\" cases.\"))\n}\n\n# compare variables names\nif (identical(colnames(dengue21), colnames(dengue21_old))){\n  print(\"Both datsets contain the same columns.\")\n} else{\n  print(paste0(\"The columns that are different are: \",\n               paste(c(setdiff(colnames(dengue21), colnames(dengue21_old)),\n                       setdiff(colnames(dengue21_old), colnames(dengue21))), collapse=\", \")))\n}\n\n# Get unique column names from both data frames\nall_columns &lt;- unique(c(names(dengue21), names(dengue21_old)))\n\n# Function to calculate the proportion of NA values in a column\nna_proportion &lt;- function(col) {\n  round(mean(is.na(col))*100,2)\n}\n\n# Apply the function to each column of the data frames\ndengue21_na &lt;- sapply(all_columns,\n                 function(col) ifelse(col %in% names(dengue21),\n                                      na_proportion(dengue21[[col]]),\n                                      NA))\ndengue21_old_na &lt;- sapply(all_columns,\n                 function(col) ifelse(col %in% names(dengue21_old),\n                                      na_proportion(dengue21_old[[col]]),\n                                      NA))\n\n# Combine the results into a new data frame\nknitr::kable(data.frame(column = all_columns, dengue21 = dengue21_na,dengue21_old = dengue21_old_na)[65:70,])\n\nIn general the count of NAs throughout the data set is similar, however in rows 66-69, corresponding to the probable areas of infection, the amount changes. In the “old” data, there is data registered, however in the newer version this data was removed."
  },
  {
    "objectID": "domrep_malaria.html",
    "href": "domrep_malaria.html",
    "title": "data4health",
    "section": "",
    "text": "domrep for malaria",
    "crumbs": [
      "Dominican Republic",
      "Malaria"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "brazil_malaria.html",
    "href": "brazil_malaria.html",
    "title": "Malaria in Brazil",
    "section": "",
    "text": "This document aims at introducing SINAN malaria data to someone with no previous experience.\nThe steps include:\n\nDownloading the data\nGetting to know the data: variables and completeness\nInformation on the patients: Age, Sex, Pregnancy and Race\nClassifying the malaria cases: detection and symptoms\nTimeline of malaria cases: distribution throughout the year, and course of the cases\nMapping spatially: municipality types, malaria types and incidences\n\nAlong the way, each topic will be divided into 3:\n\n indicates that you will learn something\n indicates that you will see the data in a plot\n indicates that there is a opportunity to filter data (if necessary).\n\n\nSetting up the R environment\n In every R script,\nIn this script we will need the following R-scripts:\n\nmicrodatasus: To download the health data from brazil\ndplyr:\npurrr:\nggplot2: to create the graphs\ntidyr:\nlubridate: to help format the dates\ngeobr: to download the shapefiles of brazils\nstringr:\n\nOther options that are being set up now include, setting a maximum waiting time for functions (i.e. timeout), how large number should be displayed (i.e. scipen) and functions are locally loaded.\n\n# load packages\npackages  &lt;- c(\"microdatasus\", \"dplyr\", \"purrr\", \"ggplot2\",\"tidyr\", \n               \"lubridate\",\"geobr\", \"stringr\")\ninvisible(install.packages(setdiff(packages, rownames(installed.packages()))))\ninvisible(lapply(packages, function(pkg) suppressMessages(require(pkg, character.only = TRUE))))\n\n# other options\noptions(scipen = 999)\noptions(timeout = 900)\n\n# load functions\nfiles.sources &lt;-  list.files(\"R/\")\ninvisible(sapply(paste0(\"R/\", files.sources), source))\n\n\n\nDownloading the data\nAs described in the download data - instructions, the health data from Brazil can be downloaded in many different ways. Here, it is downloaded with the help of the package microdatasus. The following code block will download the data for the year 2014 (which was chosen randomly).\n\n# malariaData &lt;- fetch_datasus(year_start = 2014, year_end = 2014, information_system = \"SINAN-MALARIA\")\nmalariaData &lt;- readRDS(\"data/mal14.rds\")\n\n\n\nGetting to know the Data\n\nVariables\n There are a total of 50 variables. The variables names can be seen below:\n\ncolnames(malariaData)\n\n [1] \"TP_NOT\"     \"ID_AGRAVO\"  \"DT_NOTIFIC\" \"SEM_NOT\"    \"NU_ANO\"    \n [6] \"SG_UF_NOT\"  \"ID_MUNICIP\" \"ID_REGIONA\" \"ID_UNIDADE\" \"DT_SIN_PRI\"\n[11] \"SEM_PRI\"    \"ANO_NASC\"   \"NU_IDADE_N\" \"CS_SEXO\"    \"CS_GESTANT\"\n[16] \"CS_RACA\"    \"CS_ESCOL_N\" \"SG_UF\"      \"ID_MN_RESI\" \"ID_RG_RESI\"\n[21] \"ID_PAIS\"    \"DT_INVEST\"  \"ID_OCUPA_N\" \"CLASSI_FIN\" \"AT_ATIVIDA\"\n[26] \"AT_LAMINA\"  \"AT_SINTOMA\" \"TPAUTOCTO\"  \"COUFINF\"    \"COPAISINF\" \n[31] \"COMUNINF\"   \"LOC_INF\"    \"DEXAME\"     \"RESULT\"     \"PMM\"       \n[36] \"PCRUZ\"      \"TRA_ESQUEM\" \"DSTRAESQUE\" \"DTRATA\"     \"NU_LOTE_I\" \n[41] \"DT_ENCERRA\" \"DT_DIGITA\"  \"DT_TRANSUS\" \"DT_TRANSDM\" \"DT_TRANSSM\"\n[46] \"DT_TRANSRM\" \"DT_TRANSRS\" \"DT_TRANSSE\" \"NU_LOTE_V\"  \"NU_LOTE_H\" \n\n\nThe definition of each variable can be found in the official documentation or online in Portuguese, or in this translated csv file. This file also contains the decodification for all numerical categories. A small overview of this file can be seen below:\n\nmalariaVarDefPath &lt;- file.path(getwd(), 'workspace', 'Dictionary_Malaria_EN.csv')\nmalariaVarDef &lt;- read.csv(malariaVarDefPath)\nknitr::kable(malariaVarDef[14:20,1:5])\n\n\n\n\n\n\n\n\n\n\n\n\n\nVar\nTranslation\nCategory.1\nCategory.2\nCategory.3\n\n\n\n\n14\nRACA\nSex\nWhite\nBlack\nYellow\n\n\n15\nGESTANTE1\nPregnancy\nYes\nNo\nNot applicable\n\n\n16\nNIV_ESCO_1\nEducation level\nNone\n1-3years\n4-7years\n\n\n17\nGESTANTE.\nPregnancy\n1trimester\n2trimester\n3trimester\n\n\n18\nNIV_ESCO\nEducation level\nAnalphabet\n1-4 incomplete\n4 complete\n\n\n19\nCOD_OCUP\nOccupation\nAgriculture\nPecuaria\nDomestic\n\n\n20\nTIPO_LAM\nType of detection\nPassive\nActive\nLVC\n\n\n\n\n\n To avoid working with unnecessary data, it is useful to filter out the variables that will not be used. Below is a line of code on how to select only the needed variables.\n\nsel_var &lt;- c(\"NU_IDADE_N\",\"CS_SEXO\", \"CS_GESTANT\", \"CS_RACA\", \"AT_LAMINA\", \"AT_SINTOMA\", \"DT_NOTIFIC\", \"DT_SIN_PRI\", \"DT_DIGITA\", \"DEXAME\", \"DTRATA\", \"ID_MUNICIP\",  \"ID_MN_RESI\",  \"COMUNINF\",\"RESULT\") \n\nmalariaData &lt;- malariaData %&gt;% select(all_of(sel_var))\n\n\n\nCompleteness of the data\n Some of these variables are mandatory to notify, others are not, which leads to incomplete datasets. The chart NACountChart shows the the variables which have NA-values and the percentage of NAs they contain.\n\nNACount &lt;- malariaData %&gt;% map(~mean(is.na(.)))\nNACount &lt;- data.frame(count=unlist(NACount),\n                      var=names(NACount))\n\n Visualise it!\n\nggplot(NACount[NACount$count != 0, ], aes(x = reorder(var, count), y = count)) +\n  geom_bar(stat = \"identity\", width = 0.9, position = position_dodge(width = 5)) +\n  ylab(\"Percentage of NAs in each column\") +\n  xlab(\"Variables\") +\n  coord_flip()\n\n\n\n\n\n\n\n\nOn the contrary, it is also good to know what variables are complete.\n\nNACount$var[NACount$count == 0]\n\n[1] \"NU_IDADE_N\" \"CS_SEXO\"    \"CS_GESTANT\" \"DT_NOTIFIC\" \"DT_SIN_PRI\"\n[6] \"DT_DIGITA\"  \"ID_MUNICIP\"\n\n\n To filter out variables which are (almost) completely empty,you can run the following lines.\n\ndrop_variables &lt;- NACount$var[NACount$count == 1]\nmalariaData &lt;- malariaData[, !(names(malariaData) %in% drop_variables)]\n\n\nExam results\n The database distinguishes 10 different types/combinations of malaria:\n\nNegative\nFalciparum\nF+Fg\nVivax\nF+V\nV+Fg\nFg\nMalariae\nF+M 10.Ovale\n\nThe negative notification needs to be filtered (excluded) to obtain the total malaria cases because they are not cases as the exam result was negative. Also, we should exclude NAs.\n\nmalariaData &lt;- malariaData %&gt;%\n  mutate(RESULT = as.factor(case_when(RESULT == \"1\" ~ \"Negative\",\n                                      RESULT == \"2\" ~ \"Falciparum\",\n                                      RESULT == \"3\" ~ \"F+Fg\",\n                                      RESULT == \"4\" ~ \"Vivax\",\n                                      RESULT == \"5\" ~ \"F+V\",\n                                      RESULT == \"6\" ~ \"V+Fg\",\n                                      RESULT == \"7\" ~ \"Fg\",\n                                      RESULT == \"8\" ~ \"Malariae\",\n                                      RESULT == \"9\" ~ \"F+M\",\n                                      RESULT == \"10\" ~ \"Ovale\")))\n\n Visualise it!\n\nggplot(malariaData, aes(x = RESULT, fill=RESULT)) +\n  geom_bar() +\n  annotate(\"text\", x = Inf, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(malariaData$RESULT)), \" NA values\"))+\n  labs(title=\"Exam results during malaria cases in 2014\",\n       y=\"Count\", x=\"Exam Result\", fill=\"Exam Results\") +\n  geom_text(stat = 'count', position = position_stack(vjust = 0.5),\n            aes(label = paste0(round((after_stat(count))/sum(after_stat(count)) * 100, 1), \"%\"),\n                x = RESULT))\n\n\n\n\n\n\n\n\n However, generally, people only distinguish in 3 categories: P. vivax and P. falciparum and the mixed version P+V.\n\nmalariaData &lt;- malariaData %&gt;%\n  mutate(RES_EXAM = as.factor(case_when(RESULT == \"Falciparum\" | RESULT == \"F+Fg\" | RESULT == \"Fg\" | RESULT == \"F+M\" ~ \"F\",\n                                        RESULT == \"Vivax\" | RESULT == \"V+Fg\" ~ \"V\",\n                                        RESULT == \"F+V\"  ~  \"V+F\",\n                                        RESULT == \"Malariae\" | RESULT == \"Ovale\" ~ \"other\",\n                                        RESULT == \"Negative\" ~ \"Negative\")))\n\n Visualise it!\n\nggplot(malariaData, aes(x = RES_EXAM, fill=RES_EXAM)) +\n  geom_bar() +\n  labs(title=\"Exam results during malaria cases in 2014\",\n       y=\"Count\", x=\"Exam Result\", fill=\"Exam Results\") +\n  annotate(\"text\", x = Inf, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(malariaData$RES_EXAM)), \" NA values\"))+\n  geom_text(stat = 'count', position = position_stack(vjust = 0.5),\n            aes(label = paste0(round((after_stat(count))/sum(after_stat(count)) * 100, 1), \"%\"),\n                x = RES_EXAM))\n\n\n\n\n\n\n\n\nThe majority of case are Vivax (2.9%), followed by Falciparum (2.9%). All other categories together make 100%. Fg is the gametocyte phase of the P. falciparum life cycle.\nBelow, the distribution of the most prevalent malaria can bee seen throughout the year on an epiweek time resolution. Note the vivax and falciparum cases are the combination between more than one RESULT category.\n\n\n\n\n\n\n\n\n\n To exclude cases with a negative test result, you can run the following lines\n\nmalariaData &lt;- malariaData[malariaData$RESULT != \"Negative\",]\n\n\n\n\n\nInformation on the Patients\n\nAge of patients\n For malaria, the age of the patients can be derived from NU_IDADE_N. NU_IDADE_N is codified:\n\nthe first number indicates what “dimension” it is using. 1= Hour, 2= day, 3= month, 4= year.\nthe last numbers indicate the age.\n\nThe age can be “decodified” with the command line below. This line of code also automatically removes all inconsistent ages, i.e. people over 120 years and people whose age was given in a unusual way (e.g. 84 months).\n\nmalariaData  &lt;- malariaData %&gt;%\n  mutate(AGE = case_when(NU_IDADE_N &lt; 120 ~ as.numeric(NU_IDADE_N), # assumes that non-codified data means that the age in years was given\n                           NU_IDADE_N &gt;= 120 & NU_IDADE_N &lt; 1000 ~ NA_real_,\n                           NU_IDADE_N &gt;= 1000 & NU_IDADE_N &lt; 2366 ~ 0,\n                           NU_IDADE_N &gt;= 2366 & NU_IDADE_N &lt; 3000 ~ NA_real_,\n                           NU_IDADE_N &gt;= 3000 & NU_IDADE_N &lt; 3013 ~ 0,\n                           NU_IDADE_N &gt;= 3013 & NU_IDADE_N &lt; 4000 ~ NA_real_,\n                           NU_IDADE_N &gt;= 4000 & NU_IDADE_N &lt; 4120 ~ as.numeric(NU_IDADE_N - 4000),\n                           NU_IDADE_N &gt;= 4120 ~ NA_real_,\n                           TRUE ~ NA_real_))\n\n Visualise it!\n\nggplot(malariaData, aes(x = AGE))+\n  geom_histogram(binwidth = 1, fill = \"lightblue\",color=\"black\", alpha = 0.7)+\n  annotate(\"text\", x = 100, y = Inf, label = paste0(sum(is.na(malariaData$AGE)), \" NA values\"), hjust = 1, vjust = 1, size = 4)+\n  labs(x=\"Age [years]\", y=\"Count\", title=\"Age distribution\")+\n  theme_light()\n\n\n\n\n\n\n\n\n Other datasets may include a date of birth, if provided, it can be used to corroborate the real age.\n\n\nSex of the patients\n The sex of the patients is given by CS_SEXO. A table and a barplot of its distribution can be seen below:\n\nmalariaData &lt;- malariaData %&gt;%\n  mutate(CS_SEXO = as.factor(case_when(CS_SEXO == \"F\" ~ \"Female\",\n                                       CS_SEXO == \"M\" ~ \"Male\",\n                                       CS_SEXO == \"I\" ~ \"Ignored\",\n                                       TRUE ~ \"NA\")))\n\n Visualise it!\n\n ggplot(malariaData, aes(x = CS_SEXO, fill=CS_SEXO)) +\n  geom_bar() +\n  labs(title=\"Sex distribution of malaria cases in 2015\",\n       x=\"Sex of the patient\", y=\"Count\", fill=\"Sex\")+\n  geom_text(stat = 'count', position = position_stack(vjust = 0.5),\n            aes(label = paste0(round((after_stat(count))/sum(after_stat(count)) * 100, 1), \"%\"),\n                x = CS_SEXO)) +\n  theme_light()\n\n\n\n\n\n\n\n\n\n\nPregnancy\n Another related variable is CS_GESTANT, which indicates whether the patient is pregnant. Since only women below a certain age can get pregnant this is another way to check for inconsistencies.\n\npregnant &lt;- malariaData %&gt;%\n  filter((CS_GESTANT == 1 | CS_GESTANT == 2 | CS_GESTANT ==3 | CS_GESTANT == 4)) %&gt;%\n  count()\n\nmpreg &lt;- malariaData %&gt;%\n  filter(CS_SEXO == \"M\" & (CS_GESTANT == 1 | CS_GESTANT == 2 | CS_GESTANT ==3 | CS_GESTANT == 4)) %&gt;%\n  count()\n\npover50 &lt;- malariaData %&gt;%\n  filter(AGE &gt; 50 & (CS_GESTANT == 1 | CS_GESTANT == 2 | CS_GESTANT ==3 | CS_GESTANT == 4)) %&gt;%\n  count()\n\n Out of 5 pregnant patients, there are 0 pregnant males and 0 pregnant women over the age of 50. Again, depending on the aim of the study, these patients could be excluded using the following line.\n\nmalariaData &lt;- malariaData %&gt;%\n  filter(!(CS_GESTANT %in% c(\"1\", \"2\", \"3\", \"4\") & CS_SEXO == \"M\") & \n           !(CS_GESTANT %in% c(\"1\", \"2\", \"3\", \"4\") & AGE &gt; 50))\n\n\n\nRace of the patients\n The race of the patient is given by CS_RACA. A barplot of its distribution can be seen below:\n\nmalariaData &lt;- malariaData %&gt;%\n    mutate(CS_RACA = as.factor(case_when(CS_RACA == 1 ~ \"White\",\n                                       CS_RACA == 2 ~ \"Black\",\n                                       CS_RACA == 3 ~ \"Yellow\",\n                                       CS_RACA == 4 ~ \"Brown\",\n                                       CS_RACA == 5 ~ \"Indigenous\",\n                                       CS_RACA == 9 ~ \"Ignored\",\n                                       TRUE ~ \"NA\")))\n\n Visualise it!\n\n\n\n\n\n\n\n\n\n\n\n\nClassifying the malaria cases\n\nType of detection\n Malaria can be detected either actively (when someone goes to doctor because of symptoms), passively (as protocol when one case is detected, people living in the same place are screened) or through LVC (Lamina de Verificaçao de Cura = cure thick blood smear verification). The variable AT_LAMINA, shows exactly this.\n\nmalariaData &lt;- malariaData %&gt;%\n    mutate(AT_LAMINA = as.factor(case_when(AT_LAMINA == 1 ~ \"Active\",\n                                       AT_LAMINA == 2 ~ \"Passive\",\n                                       AT_LAMINA == 3 ~ \"LVC\",\n                                       TRUE ~ \"NA\")))\n\n Visualise it!\n\nggplot(malariaData, aes(x = AT_LAMINA, fill=AT_LAMINA)) +\n  geom_bar() +\n  labs(title=\"Type of detections of malaria cases in 2014\",\n       y=\"Count\", x=\"Detection type\", fill=\"Detection type\")+\n  geom_text(stat = 'count',\n            aes(label = paste0(round((after_stat(count))/sum(after_stat(count)) * 100, 1), \"%\"),\n                x = AT_LAMINA),\n            position = position_stack(vjust = 0.5)) +\n  annotate(\"text\", x = Inf, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(malariaData$AT_LAMINA)), \" NA values\"))\n\n\n\n\n\n\n\n\nAs can be seen, most cases (65.9%) are found actively and only 7.3% are passively.\n\n\nSymptoms\n For malaria, the variable AT_SINTOMA makes the distinction whether there are symptoms present or not.\n\nmalariaData &lt;- malariaData %&gt;%\n  mutate(AT_SINTOMA = as.factor(case_when(AT_SINTOMA== \"1\" ~ \"Yes\",\n                                          AT_SINTOMA == \"2\" ~ \"No\",\n                                          TRUE ~ \"NA\")))\n\n Visualise it!\n\nggplot(data= malariaData, aes(x = AT_SINTOMA, fill=AT_SINTOMA)) +\n  geom_bar() +\n  labs(title=\"Presence of symptoms during malaria cases in 2014\",\n       y=\"Count\", x=\"Presence of symptoms\", fill=\"Presence of symptoms\") +\n  annotate(\"text\", x = Inf, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(malariaData$AT_SINTOMA)), \" NA values\"))+\n  geom_text(stat = 'count', position = position_stack(vjust = 0.5),\n            aes(label = paste0(round((after_stat(count))/sum(after_stat(count)) * 100, 1), \"%\"),\n                x = AT_SINTOMA))\n\n\n\n\n\n\n\n\nA clear majority of NA% malaria cases had symptoms.\n\n\n\nTimeline of malaria cases\n\nNotification distribution throughout the year\n In the dataset, you can find many dates, one of the most important might be the notification date DT_NOTIFIC. This is the first time that a potential malaria patient contacts the medical authorities. Below the annual distribution of notifications during 2014 can be seen. There is no clear seasonal variation but tended to concentrate cases during the summer season in Brazil.\n\nmalariaData %&gt;%\n  mutate(EPIWEEK = floor_date(DT_NOTIFIC, \"weeks\")) %&gt;%\n  group_by(EPIWEEK) %&gt;%\n  summarise(Count = n()) %&gt;%\n  ggplot() +\n  geom_line(aes(x = EPIWEEK, y = Count)) +\n  scale_x_date(date_labels = \"%m-%d\", date_breaks = \"1 week\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n\n\n\n\n\n\n\n\n\nTimeline of all other events\n First, symptoms occur (DT_SIN_TO_PRI). Once the doctor notifies a suspected malaria case (DT_NOTIFIC), it will be digitized (DT_DIGITA). The malaria case needs to be confirmed through an exam (DEXAME), and if confirmed, treated (DTRATA). Below are boxplots for each of the events date.\n\nmalariaData &lt;- malariaData %&gt;%\n  mutate(Symptoms = as.numeric(DT_SIN_PRI - DT_NOTIFIC),\n         Digitalization = as.numeric(DT_DIGITA - DT_NOTIFIC),\n         Exam = as.numeric(DEXAME - DT_NOTIFIC),\n         Treatment = as.numeric(DTRATA - DT_NOTIFIC))\n\n\nmalariaData %&gt;%\n  select(Symptoms, Digitalization, Exam, Treatment) %&gt;%\n  gather(TYPE, DAYS) %&gt;%\n  ggplot(aes(x = TYPE, y = DAYS)) +\n  geom_boxplot() +\n  coord_cartesian(ylim = c(-100, 100)) +\n  xlab(\"Event\") +\n  ylab(\"Days from the notification day\")\n\n\n\n\n\n\n\n\nThe boxplot is able to visualize possible outliers:\n\nThe first symptoms occur before the notification date, the vast majority of them in the 10 days prior to it. Symptoms that occur after the notification date or a long time before hte notification date may have to be removed.\nThe treatment, digitalization and exam dates, must fall on or within the 60 days after the notification date. If they fall outside this range, they can be coonsidered outliers and may be removed.\n\n\n\n\nMapping spatially\n\nNotification, Residence & Probable Infection\n There is of course also spatial data in the data sets. Before diving in deeper it is necessary to download the shapefiles of Brazil municipalities. This can be done via the geobr package. However, the municipality code given by geobr is one digit too long and has to be shortened to 6 digits.\nIn total, the dataset refers to 3 different locations:\n\nID_MUNICIP is the municipality where the case is notified.\nID_MN_RESI is the municipality of residence of the patient.\nCOMUNINF is the municipality the patient probably got the infection.\n\n\n# muni &lt;- read_municipality(code_muni = \"all\", year = 2014, showProgress = FALSE) %&gt;%\n#   mutate(code_muni = str_sub(code_muni, end = 6)) %&gt;%\n#   left_join(as.data.frame(table(malariaData$ID_MUNICIP, dnn = list(\"code_muni\")), responseName = \"noti_muni\")) %&gt;%\n#   left_join(as.data.frame(table(malariaData$COMUNINF, dnn = list(\"code_muni\")), responseName = \"infec_muni\")) %&gt;%\n#   left_join(as.data.frame(table(malariaData$ID_MN_RESI, dnn = list(\"code_muni\")), responseName = \"resi_muni\"))\n\nDepending on what the aim of the study is, each of these variables can be important.\n\n# cols &lt;- c(\"green\", \"yellow\",\"orange\",\"red\", \"black\") #change these as needed\n# breaks &lt;- c(0, 10, 100, 1000, 10000, 100000) #change these as needed\n# \n# ggplot(muni) +\n#   ggtitle(\"Extra-Amazon malaria per municipality of notification\") +\n#   geom_sf( aes(fill = noti_muni), size = .15, show.legend = TRUE) +\n#   scale_fill_stepsn(breaks = breaks,\n#                     colours = cols,\n#                     values = scales::rescale(breaks))\n# \n# ggplot(muni) +\n#   ggtitle(\"Extra-Amazon malaria per municipality of probable infection\") +\n#   geom_sf(aes(fill = infec_muni), size = .15, show.legend = TRUE)  +\n#   scale_fill_stepsn(breaks = breaks,\n#                     colours = cols,\n#                     values = scales::rescale(breaks))\n# \n# ggplot(muni) +\n#   ggtitle(\"Extra-Amazon malaria per municipality of residence\")+\n#   geom_sf( aes(fill = resi_muni), size = .15, show.legend = TRUE)  +\n#   scale_fill_stepsn(breaks = breaks,\n#                     colours = cols,\n#                     values = scales::rescale(breaks))\n\nWhat did you find after see the maps? Take a look of the difference between the Extra-Amazon malaria by municipality of notification and probable infection. Almost all malaria notified in the Extra-Amazon region was acquired in the Amazon region. Some people live in the Amazon region were notified in the Extra-Amazon region.\n\n\nMapping types of Malaria\nIf one wants to map them distinguishing by type, the following code can be used:\n\n# muni &lt;- muni %&gt;%\n#   left_join(as.data.frame(table(malariaData$ID_MUNICIP[malariaData$RES_EXAM == \"V\"], dnn = list(\"code_muni\")), responseName = \"vivax_muni\")) %&gt;%\n#   left_join(as.data.frame(table(malariaData$ID_MUNICIP[malariaData$RES_EXAM == \"F\"], dnn = list(\"code_muni\")), responseName = \"falci_muni\")) %&gt;%\n#   left_join(as.data.frame(table(malariaData$ID_MUNICIP[malariaData$RES_EXAM == \"V+F\"], dnn = list(\"code_muni\")), responseName = \"mixed_muni\")) %&gt;%\n#   left_join(as.data.frame(table(malariaData$ID_MUNICIP[malariaData$RES_EXAM == \"other\"], dnn = list(\"code_muni\")), responseName = \"other_muni\"))\n# \n# vivax_plot &lt;- ggplot(muni) +\n#   geom_sf( aes(fill = vivax_muni), size = .15, show.legend = TRUE) +\n#   scale_fill_viridis_c() +\n#   labs(subtitle = paste0(\"Number of P. vivax cases in Brazil 2015\"), size = 8) +\n#   theme_minimal()\n# vivax_plot\n# \n# falci_plot &lt;-  ggplot(muni) +\n#   geom_sf( aes(fill = falci_muni), size = .15, show.legend = TRUE) +\n#   scale_fill_viridis_c() +\n#   labs(subtitle=paste0(\"Number of P. falciparum cases in Brazil 2015\"), size = 8) +\n#   theme_minimal()\n# falci_plot\n# \n# mixed_plot &lt;-  ggplot(muni) +\n#   geom_sf( aes(fill = mixed_muni), size = .15, show.legend = TRUE) +\n#   scale_fill_viridis_c() +\n#   labs(subtitle=paste0(\"Number of mixed cases in Brazil 2015\"), size = 8) +\n#   theme_minimal()\n# mixed_plot\n\n\n\nCalculating the incidence\nSometimes, having the absolute values is helpful. But other times, the number of cases can be highly dependent on the number of inhabitants and then the incidence or other similar indicator is used. Another reason to use incidence is to make comparable the number of cases between areas and different times. Specifically for malaria, the analogous indicator, the Annual Parasite Index (API) is most common. This indicator is calculated by the number of malaria positive patients occurred in a specific time and place divided by the population per 1.000 inhabitants. This positive patients can be a new case or a relapse. Relapses are most common in malaria vivax infection.\nFor this, the population data needs to be loaded from IBGE either manually or using the local function “get_br_pop_data” (instructions can be viewed in 0_DownloadData.md).\n\n# get_br_pop_data(2015, save=F)\n# \n# muni &lt;-  left_join(muni, pop_2015[c(\"code_muni\",\"pop\")], by=\"code_muni\")\n# muni$pop &lt;- as.numeric(muni$pop)\n\nThe incidence is then calculated by dividing the malaria cases by the population of each municipality and multiplication by 1000.\n\n# muni$noti_inc &lt;- muni$noti_muni / muni$pop*1000\n# muni$infec_inc &lt;- muni$infec_muni / muni$pop*1000\n# muni$resi_inc &lt;- muni$resi_muni / muni$pop*1000\n# \n# breaks2 &lt;- c(0, 5, 25, 50, 100, 250)\n# noti_inci_plot &lt;- ggplot(muni) +\n#   ggtitle(\"Incidence of malaria notifications in 2015\")+\n#   geom_sf( aes(fill = noti_inc), size = .15, show.legend = TRUE)  +\n#   scale_fill_stepsn(breaks = breaks2,\n#                     colours = cols,\n#                     values = scales::rescale(breaks2))\n# noti_inci_plot\n# \n# infe_inci_plot &lt;- ggplot(muni) +\n#   ggtitle(\"Incidence of probable malaria infections in 2015\")+\n#   geom_sf(aes(fill = infec_inc), size = .15, show.legend = TRUE)  +\n#   scale_fill_stepsn(breaks = breaks2,\n#                     colours = cols,\n#                     values = scales::rescale(breaks2))\n# infe_inci_plot\n# \n# resi_inci_plot &lt;- ggplot(muni) +\n#   ggtitle(\"Incidence of residents with malaria in 2015\")+\n#   geom_sf(aes(fill = resi_inc), size = .15, show.legend = TRUE)  +\n#   scale_fill_stepsn(breaks = breaks2,\n#                     colours = cols,\n#                     values = scales::rescale(breaks2))\n# resi_inci_plot\n\nIf one wants to know the incidence depending on the malaria type:\n\n# muni$vivax_inc &lt;- muni$vivax_muni / muni$pop*1000\n# muni$falci_inc &lt;- muni$falci_muni / muni$pop*1000\n# muni$mixed_inc &lt;- muni$mixed_muni / muni$pop*1000\n# \n# vivax_inci_plot &lt;- ggplot(muni) +\n#   geom_sf(aes(fill = vivax_inc), size = .15, show.legend = TRUE) +\n#   scale_fill_viridis_c() +\n#   labs(subtitle = paste0(\"Vivax incidence in Brazil 2015\"), size = 8) +\n#   theme_minimal()\n# vivax_inci_plot\n# \n# falci_inci_plot&lt;- ggplot(muni) +\n#   geom_sf( aes(fill = falci_inc), size = .15, show.legend = TRUE) +\n#   scale_fill_viridis_c()+\n#   labs(subtitle = paste0(\"Falciparum incidence in Brazil in 2015\"), size = 8) +\n#   theme_minimal()\n# falci_inci_plot\n# \n# mixed_inci_plot&lt;- ggplot(muni) +\n#   geom_sf( aes(fill = mixed_inc), size = .15, show.legend = TRUE) +\n#   scale_fill_viridis_c()+\n#   labs(subtitle = paste0(\"Mixed incidence in Brazil in 2015\"), size = 8) +\n#   theme_minimal()\n# mixed_inci_plot",
    "crumbs": [
      "Brazil",
      "Malaria"
    ]
  },
  {
    "objectID": "brazil_dengue.html",
    "href": "brazil_dengue.html",
    "title": "1b_DengueData",
    "section": "",
    "text": "This document aims at introducing dengue data to someone with no previous experience. Before starting it is necessary to have the health data, instructions on how to obtain these are in the ReadMe of this project.\nThe steps include:\n\nDownloading the data\nGetting to know the data: detect differences between different datasets\nInformation on the patients: Age, Sex, Pregnancy, Race\nInformation ono the case: classification, confirmation criteria, dengue category, exam type, evolution of the case\nTimeline of the dengue case: distribution throughout the year, duration of cases, course of the disease\nMapping spatially: Absolute cases, incidence\n\nAlong the way, each topic will be divided into 3:\n\n indicates that you will learn something\n indicates that you will see the data in a plot\n indicates that there is a opportunity to filter data (if necessary).\n\n\n#load packages\npackages  &lt;- c(\"tidyverse\", \"microdatasus\", \"foreign\", \"readr\", \"dplyr\", \"purrr\",\n               \"ggplot2\",\"tidyr\", \"lubridate\",\"geobr\", \"stringr\", \"patchwork\",\n               \"arsenal\", \"read.dbc\")\ninvisible(install.packages(setdiff(packages, rownames(installed.packages()))))\ninvisible(lapply(packages, function(pkg) suppressMessages(require(pkg, character.only = TRUE))))\n\n# other options\noptions(scipen = 999)\noptions(timeout = 2000)\n\n# load functions\nfiles.sources &lt;-  list.files(\"R/\")\ninvisible(sapply(paste0(\"R/\", files.sources), source))\n\n\nDownload the data by microdatasus\nAs described in the ReadMe, the health data from Brazil can be downloaded by many different methods: microdatasus, PySUS or by Filezilla FTP link. In this script, the data will be downloaded with the help of the package microdatasus, the following code block is an example that will download the data for the year 2015 and 2021. The dengue database is heavy and it can take time to download it. It is therefor recommended to download and save it before the analysis and to simply load the datasets once you do the analysis. (In the case of this script, run it once entirely, and then you can comment out the first code block to not download the same data over and over.)\nSometimes problems with the variables occur when downloading data from mutiple years (e.g. 2012 to 2015). The developer are already aware of this. For now, download each year one by one, then import all years using bind_rows and use an argument to import all variables as a character.\n\n# den15 &lt;- fetch_datasus(year_start = 2015, year_end = 2015, information_system = \"SINAN-DENGUE\")\n# den21 &lt;- fetch_datasus(year_start = 2021, year_end = 2021, information_system = \"SINAN-DENGUE\")\nden15 &lt;- readRDS(\"data/den15.rds\")\nden21 &lt;- readRDS(\"data/den21.rds\")\n\n\nUnderstanding the data structure\n Specifically, it contains 139 variables, the explanation for each variable can be found on the SINAN webpage from the Ministry of Health of Brazil. However, it is only available in Portuguese. A translation into English can be found in this csv file. This file also contains the decodification for all numerical categories. A small overview of this file can be seen below:\n\nvarEng &lt;- read_csv(\"workspace/Dictionary_Dengue.csv\")\nknitr::kable(head(varEng[,1:4]))\n\n\n\n\nVar\nEng\n1\n2\n\n\n\n\nACIDO_PEPT\nPreexistence of peptic acid illness\nYes\nNo\n\n\nALRM_ABDOM\nAlarm sign: Abdominal pain\nYes\nNo\n\n\nALRM_HEMAT\nAlarm sign: Hematocrit increase\nYes\nNo\n\n\nALRM_HEPAT\nAlarm sign: Hepatomegaly\nYes\nNo\n\n\nALRM_HIPOT\nAlarm sign: Hipotension\nYes\nNo\n\n\nALRM_LETAR\nAlarm sign: Lethargy or irritability\nYes\nNo\n\n\n\n\n\nSome of these variables are mandatory to notify, others are not, which leads to incomplete datasets. The dataframe NAcount shows the percentage of NA-values for each variable, below you can see it graphically for some of the variables. Here, we chose as the main database to explore the variables, den15, a database you can download by the FTP link.\n\nNAcount &lt;- den15 %&gt;% map(~mean(is.na(.)))\nNAcount &lt;- data.frame(unlist(NAcount))\nNAcount[\"var\"] &lt;- rownames(NAcount)\n\n You can visualise it here.\n\np &lt;- ggplot(NAcount[35:55,], aes(x = reorder(var, unlist.NAcount.), y = unlist.NAcount.))+\n  geom_bar(stat = \"identity\", width = 0.9, position = position_dodge(width = 5))+\n  ylab(\"Percentage of NAs in each column\")+\n  xlab(\"Variables\")\np + coord_flip()\n\n\n\n\n\n\n\n\nThe variables with complete datasets are:\n\nNAcount$var[NAcount$unlist.NAcount. == 0]\n\n[1] \"TP_NOT\"     \"ID_AGRAVO\"  \"DT_NOTIFIC\" \"SEM_NOT\"    \"NU_ANO\"    \n[6] \"SG_UF_NOT\"  \"ID_MUNICIP\" \"SEM_PRI\"    \"NU_IDADE_N\"\n\n\n To avoid working with unnecessary data, it is useful to filter out the variables that will not be used. Below is a line of code on how to select only the needed variables.\nChange this list as needed!\n\nsel_var &lt;- c(\"DT_NOTIFIC\",  \"ID_MUNICIP\",  \"DT_SIN_PRI\", \"DT_NASC\", \"NU_IDADE_N\", \n             \"CS_SEXO\", \"CS_GESTANT\", \"CS_RACA\", \"ID_MN_RESI\",  \"COMUNINF\", \n             \"CLASSI_FIN\", \"CRITERIO\",  \"EVOLUCAO\", \"DT_OBITO\", \"DT_SORO\",  \n             \"DT_ENCERRA\", \"RES_CHIKS1\",\"RES_CHIKS2\", \"RESUL_PRNT\",\"RESUL_SORO\",\"RESUL_NS1\",\n             \"RESUL_VI_N\", \"RESUL_PCR_\",\"HISTOPA_N\",\"IMUNOH_N\", \"MUNICIPIO\")\n\nden15 &lt;- den15 %&gt;% select(all_of(sel_var))\n\n\n\nThere is library in Python that can help https://pypi.org/project/pandas-dedupe/. ver 2015, esse veio do ministério\n\n# Filtro: duplicidade ----\n# den15 %&gt;%\n#   distinct(NU_NOTIFIC, DT_NOTIFIC, ID_MUNICIP, .keep_all = T) %&gt;% count()\n#\n# den15 %&gt;%\n#   distinct(NU_NOTIFIC, DT_NOTIFIC, ID_MUNICIP, DT_NASC, ID_UNIDADE, .keep_all = T) %&gt;% count()\n\n\n\n\nInformation on the patient\n\nAge\n For dengue, there are two methods to obtain the age of the patients. First, using the data about the patients birth-date, which is provided in the variable DT_NASC. The age can be calculated by subtracting the birth-date from the notification date.\n\nden15 &lt;- den15 %&gt;%\n    mutate(AGE_BIRTHDAY =\n             ifelse(format(den15$DT_NASC, \"%m-%d\") &gt; format(den15$DT_NOTIFIC, \"%m-%d\"),\n                    year(den15$DT_NOTIFIC)-year(den15$DT_NASC)-1,\n                    year(den15$DT_NOTIFIC)-year(den15$DT_NASC)))\n\n You can visualise it here\n\nggplot(den15, aes(x = AGE_BIRTHDAY))+\n  geom_histogram(binwidth = 1, fill = \"lightblue\",color=\"black\", alpha = 0.7)+\n  annotate(\"text\", x = 100, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(den15$AGE_BIRTHDAY)), \" NA values\"))+\n  labs(x=\"Age [years]\", y=\"Count\", title=\"Age distribution according to the birthday field\")+\n  theme_light()\n\n\n\n\n\n\n\n\n However, DT_NASC is not a mandatory variable, thus, there are many missing values. Instead, NU_IDADE_N can be used. NU_IDADE_N is codified as follows:\n\nthe first number indicates what “dimension” it is using. 1= Hour, 2= day, 3= month, 4= year.\nthe last numbers indicate the age. The age can be “decodified” with the below command line.\n\n\nden15  &lt;- den15 %&gt;%\n  mutate(AGE_CODE = case_when(NU_IDADE_N &lt; 120 ~ as.numeric(NU_IDADE_N), # assumes that non-codified data means that the age in years was given\n                           NU_IDADE_N &gt;= 120 & NU_IDADE_N &lt; 1000 ~ NA_real_,\n                           NU_IDADE_N &gt;= 1000 & NU_IDADE_N &lt; 2366 ~ 0,\n                           NU_IDADE_N &gt;= 2366 & NU_IDADE_N &lt; 3000 ~ NA_real_,\n                           NU_IDADE_N &gt;= 3000 & NU_IDADE_N &lt; 3013 ~ 0,\n                           NU_IDADE_N &gt;= 3013 & NU_IDADE_N &lt; 4000 ~ NA_real_,\n                           NU_IDADE_N &gt;= 4000 & NU_IDADE_N &lt; 4120 ~ as.numeric(NU_IDADE_N - 4000),\n                           NU_IDADE_N &gt;= 4120 ~ NA_real_,\n                           TRUE ~ NA_real_))\n\nggplot(den15[den15$AGE_CODE &lt; 120,], aes(x = AGE_CODE))+\n  geom_histogram(binwidth = 1, fill = \"lightblue\",color=\"black\", alpha = 0.7)+\n  annotate(\"text\", x = 100, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(den15$AGE_CODE)), \" NA values\"))+\n  labs(x=\"Age [years]\", y=\"Count\",\n       title=\"Age distribution according to the codified age field\")+\n  theme_light()\n\n\n\n\n\n\n\n\nThe two histograms are very similar, however there is a noticeable difference in the amount of people aged 0. Below are the first few lines of cases where the two calculated ages differ:\n\ncompare_age &lt;- den15[(den15$AGE_BIRTHDAY - den15$AGE_CODE) &gt;1,] %&gt;%\n  select(DT_NASC, NU_IDADE_N, AGE_CODE, AGE_BIRTHDAY)\nknitr::kable(head(compare_age[!is.na(compare_age$DT_NASC),]))\n\n\n\n\n\nDT_NASC\nNU_IDADE_N\nAGE_CODE\nAGE_BIRTHDAY\n\n\n\n\n16\n1961-02-03\n2001\n0\n53\n\n\n351\n2001-08-21\n4010\n10\n13\n\n\n472\n1994-12-24\n2001\n0\n20\n\n\n1100\n2009-02-26\n3002\n0\n6\n\n\n1252\n1991-07-08\n2001\n0\n23\n\n\n1395\n2000-06-11\n2001\n0\n14\n\n\n\n\n\n There are many people with an age code of 0, but with an birthdate, that indicates a diferent age. Another common way to filter inconsistencies is to discard people above the age of 120.\n\n\n\nSex of the patients\n The sex of the patients is given by CS_SEXO.\n\nden15 &lt;- den15 %&gt;%\n  mutate(CS_SEXO = as.factor(case_when(CS_SEXO == \"F\" ~ \"Female\",\n                                       CS_SEXO == \"M\" ~ \"Male\",\n                                       CS_SEXO == \"I\" ~ \"Ignored\",\n                                       TRUE ~ \"NA\")))\n\n A bar plot of its distribution can be seen below:\n\nggplot(den15, aes(x = CS_SEXO, fill=CS_SEXO))+\n  geom_bar()+\n  ggtitle(\"Sex distribution of dengue cases in 2015\")+\n  labs(x = \"Sex of the patient\", y = \"Count\", fill=\"Sex\")+\n  annotate(\"text\", x = Inf, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(den15$CS_SEXO)), \" NA values\"))+\n  theme_light()\n\n\n\n\n\n\n\n\n\n\nPregnancy\n Another related variable is CS_GESTANT, which indicates whether the patient is pregnant. Since only women below a certain age can get pregnant this is another way to check for inconsistencies.\n\npregnant &lt;- den15 %&gt;%\n  filter((CS_GESTANT == 1 | CS_GESTANT == 2 | CS_GESTANT ==3 | CS_GESTANT == 4)) %&gt;%\n  count()\n\nmpreg &lt;- den15 %&gt;%\n  filter(CS_SEXO == \"M\" & (CS_GESTANT == 1 | CS_GESTANT == 2 | CS_GESTANT ==3 | CS_GESTANT == 4)) %&gt;%\n  count()\n\npover50 &lt;- den15 %&gt;%\n  filter(AGE_CODE &gt; 50 & (CS_GESTANT == 1 | CS_GESTANT == 2 | CS_GESTANT ==3 | CS_GESTANT == 4)) %&gt;%\n  count()\n\n Out of 13382 pregnant patients, there are 0 pregnant males and 764 pregnant women over the age of 50. Again, depending on the aim of the study, these patients could be excluded using the following line.\n\nden15 &lt;- den15 %&gt;%\n  filter(!(CS_GESTANT %in% c(\"1\", \"2\", \"3\", \"4\") & CS_SEXO == \"M\") & \n           !(CS_GESTANT %in% c(\"1\", \"2\", \"3\", \"4\") & AGE_CODE &gt; 50))\n\n\n\nRace/Color of the patients\n The race/color of the patient is given by CS_RACA.\n\nden15 &lt;- den15 %&gt;%\n    mutate(CS_RACA = as.factor(case_when(CS_RACA == 1 ~ \"White\",\n                                       CS_RACA == 2 ~ \"Black\",\n                                       CS_RACA == 3 ~ \"Yellow\",\n                                       CS_RACA == 4 ~ \"Brown\",\n                                       CS_RACA == 5 ~ \"Indigenous\",\n                                       CS_RACA == 9 ~ \"Ignored\",\n                                       TRUE ~ \"NA\")))\n\n\n\nggplot(den15, aes(x = CS_RACA, fill=CS_RACA)) +\n  geom_bar() +\n  ggtitle(\"Race/Color distribution of dengue cases in 2015\") +\n  geom_text(stat = 'count',\n            aes(label = paste0(round((after_stat(count))/sum(after_stat(count)) * 100, 1), \"%\"),\n                x = CS_RACA),\n            position = position_stack(vjust = 0.5)) +\n  labs(x=\"Race/Color of the patient\", y=\"Count\",fill=\"Race/Color\")\n\n\n\n\n\n\n\n\nNote the amount of missing values and ignored for race/color.\n\n\n\nInformation on the cases\n\nClassification of the dengue cases\n This database collects all the suspected cases of dengue, however, not all suspected cases are considered as probable or confirmed. The variable CLASSI_FIN gives insight about the final classification and severity of each case. It is important to note that since 2015 there are new classification rules, consequently the codification of this variables changed too. Before 2015 the numbers 1-5 were used, and now 5-13 (5 always meing “discarded”). The code is as follows:\n1 - Classic Dengue Fever 2 - Severe Dengue 3 - Dengue Hemorrhagic Fever - DHF 4 - Dengue Shock Syndrome 5 - Discarded 8 - Inconclusive 10 - Dengue 11 - Dengue with warning signs) 12 - Severe Dengue 13 - Chikungunya\n\nclassification &lt;- den15 %&gt;%\n   mutate(\n     CLASSI_FIN = as.factor(case_when(CLASSI_FIN == 1 ~ \"Dengue\",\n                                      CLASSI_FIN == 2 ~ \"Severe Dengue\",\n                                      CLASSI_FIN == 3 ~ \"Dengue Hemorrhagic Fever\",\n                                      CLASSI_FIN == 4 ~ \"Dengue Shock Syndrome\",\n                                      CLASSI_FIN == 5 ~ \"Discarded\",\n                                      CLASSI_FIN == 8 ~ \"Inconclusive\",\n                                      CLASSI_FIN == 10 ~ \"Dengue\",\n                                      CLASSI_FIN == 11 ~ \"Dengue with \\nwarning signals\",\n                                      CLASSI_FIN == 12 ~ \"Severe Dengue\",\n                                      CLASSI_FIN == 13 ~ \"Chikungunya\",\n                                      TRUE ~ \"NA\")))\n\n\n\nggplot(classification) +\n  geom_bar(aes(x = CLASSI_FIN, fill=CLASSI_FIN)) +\n  geom_text(stat = 'count',\n            aes(label = paste0(round((after_stat(count))/sum(after_stat(count)) * 100, 1), \"%\"),\n                x = CLASSI_FIN),\n            position = position_stack(vjust = 0.5)) +\n  labs(x=\"Classification category\",\n       y=\"Count\",\n       title=\"Final classification of dengue cases in 2021\",\n       fill= \"Classification\")+\n  theme_minimal()\n\n\n\n\n\n\n\n\n Almost 29.1% of the cases in 2021 were discarded. If a study only considers probable dengue cases, these discarded cases, as well as those without classification, should be discarded.\n\n\nConfirmation criteria of the cases\n It can be of interest how the dengue case are confirmed. Information about the type of confirmation can be extracted from the variable CRITERIO. In Brazil there are three different options:\n\nlaboratory exams\nclinical epidemiological, which means that a physician talked to the patient.\nUnknown\n\n\ncriteria &lt;-  den15 %&gt;%\n  count(CRITERIO, name = \"count\") %&gt;%\n  mutate(percentage = prop.table(count),\n         category = c(\"Laboratory\", \"Clinical epidimiological\",\"Under investigation\",\"Unknown\"))\n\n\nggplot(criteria, aes(x = category, y = count, fill = category)) +\n  geom_bar(stat = \"identity\") +\n  geom_text(aes(label = paste0(round(percentage * 100, 1), \"%\")),\n            position = position_stack(vjust = 0.5)) +\n  labs(x = \"Confirmation criteria\",\n       y = \"Count\",\n       title = \"Confirmation criteria of dengue cases in 2015\",\n       fill = \"Confirmation Criteria\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n49.8% of the cases were confirmed/discarded via the criteria of clinical epiediomogical, and 36.6% via laboratory exams. A detailed description of which exams are tipically used can be seen in the exam type section.\n If you are interest solely in confirmed cases, then all cases with unknown or missing criteria have to be dismissed.\n\n\nCategories of dengue\n Based on its classification and confirmation criterium, dengue cases can be categorized into 4 different categories. They have been mentioned in the previous sections, but for clarity they are listed and defined here again:\n\nSuspect cases: all notifications.\nConfirmed cases: dengue cases confirmed by laboratory or clinic-epidemiological criteria.\nProbable cases: dengue cases discarding missing values and discarded category of the CLASSI_FIN variable.\nDiscarded category of the CLASSI_FIN variable.\n\n\n\nExam type\n In the case of confirmation via laboratory exams, there are 9 different possible exams. Each exam has its own variable, with a numerical code that indicates its result:\n\nmeans the result of the exam is positive\nmeans the result of the exam is negative\nmeans the result of the exam is inconclusive\nmeans the exam was not realized\n\n\nexams &lt;- den15 %&gt;%\n  filter(CRITERIO == 1) %&gt;%\n  summarise('Serological exam 1 (Chikungunya)' = sum(!is.na(RES_CHIKS1) & RES_CHIKS1 != 4 ),\n            'Serological exam 2 (Chikungunya)' = sum(!is.na(RES_CHIKS2) & RES_CHIKS2 != 4),\n            'PRNT exam' = sum(!is.na(RESUL_PRNT) & RESUL_PRNT != 4),\n            'Serological exam (dengue)' = sum(!is.na(RESUL_SORO) & RESUL_SORO != 4),\n            'NS1 exam' = sum(!is.na(RESUL_NS1) & RESUL_NS1 != 4),\n            'Viral isolation' = sum(!is.na(RESUL_VI_N) & RESUL_VI_N != 4),\n            'PCR exam' = sum(!is.na(RESUL_PCR_) & RESUL_PCR_ != 4),\n            'Histopatology exam' = sum(!is.na(HISTOPA_N) & HISTOPA_N != 4),\n            'Immunohistochemistry exam' = sum(!is.na(IMUNOH_N) & IMUNOH_N != 4))\nexams &lt;-  data.frame(var= colnames(exams), val= t(exams))\n\n\nggplot(exams, aes(x = var, y = val, fill=val)) +\n  geom_bar(stat = \"identity\",aes(reorder(var, val), val)) +\n  ggtitle(\"Frequency of each lab exam performed for dengue cases in 2015\") +\n  xlab(\"Exams\") +\n  theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5))+\n  ylab(\"Count\")\n\n\n\n\n\n\n\n\nAs can be seen, the serological exam is by far the most used one, followed by NS1. The other exams are hardly used.\n\n\nEvolution of case\n Finally, the variable EVOLUCAO defines the outcome of each dengue case.\n\nevolution &lt;- den15 %&gt;%\n   mutate(\n     EVOLUCAO = as.factor(case_when(EVOLUCAO == 1 ~ \"Cured\",\n                                    EVOLUCAO == 2 ~ \"Death by \\nillness\",\n                                    EVOLUCAO == 3 ~ \"Death by \\nother cause\",\n                                    EVOLUCAO == 4 ~ \"Death under \\ninvestigation\",\n                                    EVOLUCAO == 9 ~ \"Ignored\",\n                                    TRUE ~ \"NA\")))\n\nggplot(evolution) +\n  geom_bar(aes(x = EVOLUCAO, fill= EVOLUCAO)) +\n  geom_text(stat = 'count',\n            aes(label = paste0(round((after_stat(count))/sum(after_stat(count)) * 100, 1), \"%\"),\n                x = EVOLUCAO),\n            position = position_stack(vjust = 0.5)) +\n  labs(x=\"Category\", y = \"Count\", fill=\"Category\", title=\"Final outcomes of dengue cases in 2015\" )\n\n\n\n\n\n\n\n\n\n\n\nTimeline of dengue cases\n\nNotification distribution throughout the year\n The date of the first time that a potential dengue patient contacts the medical authorities is recorded as DT_NOTIF. This variable can be used to see clear temporal patterns throughout the year. Below, there is the annual distribution of dengue notifications in 2015, plotted at a temporal resolution of epidemiological week. In an epidemiological week, the week starts on Sunday.\n\ndengueEpiWeek &lt;- den15 %&gt;%\n  mutate(epiweek = paste0(sprintf(\"%02d\",epiweek(DT_NOTIFIC)), \"-2015\")) %&gt;%\n  group_by(epiweek) %&gt;%\n  summarise(count = n()) %&gt;%\n  select(epiweek, count)\n\n\nggplot(dengueEpiWeek, aes(x = epiweek, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"lightblue\", color=\"darkgrey\",alpha = 0.7)+\n  annotate(\"text\", x = Inf, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(den15$DT_NOTIFIC)), \" NA values\")) +\n  theme_minimal() +\n  labs(title = \"Suspected dengue cases in 2015 by epiweek\",\n       x = \"Epiweek\",\n       y = \"Count\") +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))\n\n\n\n\n\n\n\n\nThere is a clear seasonal variation, with the peak presenting itself in the middle of the Autumn season in Brazil.\n\n\nDuration of each dengue case\n Once the initial notification happens, the timeline of each case starts. The duration of the complete process is delimited by the “closing date” (DT_ENCERRA). Below is a histogram to see the duration of each dengue case.\n\nduration &lt;- as.numeric(den15$DT_ENCERRA - den15$DT_NOTIFIC)\n\n\nggplot(data.frame(duration = duration[duration &lt; 100]), aes(x = duration)) +\n  geom_histogram(bins = 100, fill = \"lightblue\",color=\"black\", alpha = 0.7)+\n  annotate(\"text\", x = Inf, y = Inf, hjust = 1, vjust = 1, size = 4,\n           label = paste0(sum(is.na(den15$DT_ENCERRA)), \" NA values\")) +\n  labs(title = \"Duration from notification to closing of the case\",\n       x = \"Time [days]\",\n       y = \"Count\")\n\nWarning: Removed 19525 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\n\n\nThere is an extremely large amount of cases that end on the 61st day, to be specific 20.01%. Only 10.14% of the case take longer than 61 days.\n\n\nTimeline of all other events\n There are many dates recorded to be able ti understand the course of the disease. First, symptoms occur (DT_SIN_PRI), this occurs before the notification date. Once the doctor notified a dengue suspicion (DT_NOTIF) the case needs to be confirmed via an exams, this should happen shortly after the notification. Finally, there must be a closing date (DT_ENCERRA) or date of death (DT_OBITO). Both of these have to be after the notification date.\n\ntime &lt;- data.frame(A_SYMP = as.numeric(den15$DT_SIN_PRI - den15$DT_NOTIFIC),\n                   B_SORO = as.numeric(den15$DT_SORO - den15$DT_NOTIFIC),\n                   C_DEAD = as.numeric(den15$DT_OBITO - den15$DT_NOTIFIC),\n                   D_TOTAL = as.numeric(den15$DT_ENCERRA - den15$DT_NOTIFIC))\nlong &lt;- gather(time, TYPE, DAYS, A_SYMP:D_TOTAL)\n\n\nggplot(long, aes(x = TYPE, y = DAYS)) +\n  geom_boxplot() +\n  coord_cartesian(ylim = c(-100, 100)) +\n  labs(x=\"Event\",\n       y=\"Days from the notification day\",\n       title=\"\") +\n  scale_x_discrete(labels = c(\"First Symptoms\", \"Sorological Exam\", \"Death\", \"Case closed\"))\n\nWarning: Removed 4089321 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n Most dates should fall within a few days before the notification day or within two months after it. However, looking at the boxplots, this is clearly not the case. If one wants to work with the timeline of dengue cases, these erroneous cases need to be removed, e.g. someone dying before the notification date or someone having their first symptoms on the 215-04-03.\n\n\n\nMapping spatially\n\nAbsolute cases\n There is of course also spatial data in the datasets. Before beginning the analysis, it is necessary to download the shapefiles of Brazils municipalities. This can be done via the geobr package (more info on this in 0_DownloadData.md). However, the municipality code given by geobr is one digit too long and has to be shortened to 6 digits.\n\nmuni &lt;- read_municipality(code_muni = \"all\", year = 2015, showProgress = FALSE) %&gt;%\n  mutate(code_muni = str_sub(code_muni, end = 6))\n\nIn total, the dataset refers to 4 different locations:\n\nID_MUNICIP is the municipality where the case is recorded.\nID_MN_RESI is the municipality of residence of the patient.\nCOMUNINF is the probable municipality of infection.\nMUNICIPIO is the municipality of the hospital (if hospitalized).\n\n\nnoti &lt;- as.data.frame(table(den15$ID_MUNICIP, dnn = list(\"code_muni\")), responseName = \"noti_muni\")\ninfec &lt;- as.data.frame(table(den15$COMUNINF, dnn = list(\"code_muni\")), responseName = \"infec_muni\")\nresi &lt;- as.data.frame(table(den15$ID_MN_RESI, dnn = list(\"code_muni\")), responseName = \"resi_muni\")\nhosp &lt;- as.data.frame(table(den15$MUNICIPIO, dnn = list(\"code_muni\")), responseName = \"hosp_muni\")\n\nallmuni &lt;- left_join(muni, noti) %&gt;%\n  left_join(., infec) %&gt;%\n  left_join(., resi) %&gt;%\n  left_join(., hosp)\n\ncols &lt;- c(\"green\", \"yellow\",\"orange\",\"red\", \"black\")\nbreaks &lt;- c(0,10,100,1000,10000,100000)\nnoti &lt;- ggplot(allmuni) +\n  ggtitle(\"Notification municipality\")+\n  geom_sf( aes(fill=noti_muni), size=.15, show.legend = TRUE) +\n  scale_fill_stepsn(breaks = breaks,\n                    colours = cols,\n                    values= scales::rescale(breaks))\n\ninfec &lt;- ggplot(allmuni) +\n  ggtitle(\"Probable infections municipality\")+\n  geom_sf( aes(fill=infec_muni), size=.15, show.legend = TRUE)  +\n  scale_fill_stepsn(breaks = breaks,\n                    colours = cols,\n                    values= scales::rescale(breaks))\n\nresi &lt;- ggplot(allmuni) +\n  ggtitle(\"Residence municipality\")+\n  geom_sf( aes(fill=resi_muni), size=.15, show.legend = TRUE)  +\n  scale_fill_stepsn(breaks = breaks,\n                    colours = cols,\n                    values= scales::rescale(breaks))\n\nhosp &lt;- ggplot(allmuni) +\n  ggtitle(\"Hospitalizations municipality\")+\n  geom_sf( aes(fill=hosp_muni), size=.15, show.legend = TRUE)  +\n  scale_fill_stepsn(breaks = breaks,\n                    colours = cols,\n                    values= scales::rescale(breaks))\n\n#using the patchwork library, the plots can be displayed next to each other\n(noti+infec)/(resi+hosp)\n\n\n\n\n\n\n\n\nDepending on the aim of the study, different variables can be important. For example, if your work aims to understand the dengue prevalence, the municipality of residence is the most suitable. However, if you need to evaluate the healthcare infrastructure, the municipality of hospitalisation could be more suitable.\n\n\nCalculate the incidence\n Sometimes, having the absolute values is helpful. But other times, the number of dengue cases are highly dependent on the number of inhabitants and then the incidence is used. The incidence describes how many dengue cases occurred per 100.000 inhabitants.\nFor this, the population data needs to be loaded from IBGE either manually or using the local function “get_br_pop_data” (instructions can be viewed in 0_DownloadData.md).\n\nget_br_pop_data(2015, save=F)\n\nallmuni &lt;-  left_join(allmuni, pop_2015[c(\"code_muni\",\"pop\")], by=\"code_muni\")\nallmuni$pop &lt;- as.numeric(allmuni$pop)\n\nThe incidence is then calculated by dividing the dengue cases by the population of each municipality and multiplicating it by 100.000.\n\nallmuni$noti_inc &lt;- allmuni$noti_muni / allmuni$pop * 100000\nallmuni$infec_inc &lt;- allmuni$infec_muni / allmuni$pop * 100000\nallmuni$resi_inc &lt;- allmuni$resi_muni / allmuni$pop * 100000\nallmuni$hosp_inc &lt;- allmuni$hosp_muni / allmuni$pop * 100000\n\n# Population\nggplot(allmuni) +\n  ggtitle(\"Population in Brazil\")+\n  geom_sf( aes(fill = pop), size = .15, show.legend = TRUE)  +\n  scale_fill_stepsn(breaks = breaks,\n                    colours = cols,\n                    values= scales::rescale(breaks))\n\n\n\n\n\n\n\n# Incidence\nbreaks2 &lt;- c(0,5,25,50,100, 250)\nnoti_inc &lt;- ggplot(allmuni) +\n  ggtitle(\"Incidence of dengue notifications in 2015\")+\n  geom_sf( aes(fill = noti_inc), size = .15, show.legend = TRUE)  +\n  scale_fill_stepsn(breaks = breaks2,\n                    colours = cols,\n                    values = scales::rescale(breaks2))\ninfec_inc &lt;- ggplot(allmuni) +\n  ggtitle(\"Incidence of probable dengue infections in 2015\")+\n  geom_sf( aes(fill = infec_inc), size = .15, show.legend = TRUE)  +\n  scale_fill_stepsn(breaks = breaks2,\n                    colours = cols,\n                    values = scales::rescale(breaks2))\nresi_inc &lt;- ggplot(allmuni) +\n  ggtitle(\"Incidence of residents with dengue in 2015\")+\n  geom_sf( aes(fill = resi_inc), size = .15, show.legend = TRUE)  +\n  scale_fill_stepsn(breaks = breaks2,\n                    colours = cols,\n                    values = scales::rescale(breaks2))\nhosp_inc &lt;- ggplot(allmuni) +\n  ggtitle(\"Incidence of dengue hospitalizations in 2015\")+\n  geom_sf( aes(fill = hosp_inc), size = .15, show.legend = TRUE) +\n  scale_fill_stepsn(breaks = breaks2,\n                    colours = cols,\n                    values = scales::rescale(breaks2))\n\n(noti_inc+infec_inc)/(resi_inc+hosp_inc)",
    "crumbs": [
      "Brazil",
      "Dengue"
    ]
  },
  {
    "objectID": "ui_tool.html",
    "href": "ui_tool.html",
    "title": "ui_tool",
    "section": "",
    "text": "If you dont want to code, you can use this tool, developed within the HARMONIZE project. It aims to streamline health data analysis for researchers and decision makers wihthout the need of coding. It contains the following steps:\n\nYou can input data at any step and also download the result of any step.\nThe ‘access data’ is currently available for Brazil and will be available for Peru, Colombia and Dominican Republic in the near future. All other steps can be performed for any data as long as it has the correct data format."
  },
  {
    "objectID": "colombia_dengue.html",
    "href": "colombia_dengue.html",
    "title": "data4health",
    "section": "",
    "text": "colombia dengue",
    "crumbs": [
      "Colombia",
      "Dengue"
    ]
  },
  {
    "objectID": "domrep.html",
    "href": "domrep.html",
    "title": "data4health",
    "section": "",
    "text": "this will start page for domrep",
    "crumbs": [
      "Dominican Republic"
    ]
  },
  {
    "objectID": "reports.html",
    "href": "reports.html",
    "title": "reports",
    "section": "",
    "text": "Here you can find reports:\n\ngeneral public\nTechnical"
  },
  {
    "objectID": "colombia.html",
    "href": "colombia.html",
    "title": "data4health",
    "section": "",
    "text": "start page for colombia",
    "crumbs": [
      "Colombia"
    ]
  },
  {
    "objectID": "brazil_download_data.html",
    "href": "brazil_download_data.html",
    "title": "0_Download",
    "section": "",
    "text": "How to download Health Data\nHere you can find four different ways to download the anonymised raw health Brazilian data. If you do not need the raw data, you can access the DataSUS tabnet webpage and customise tables as you need it.\nDepending on the disease, the available date changes because of the year the disease was introduced and / or started the notification and / or became a mandatory disease notification in Brazil. The minimum year available on SINAN FTP link is 2000. The minimum year available on SIVEP is 2003. If you need years before it and / or nominal data and data from SIVEP, you have to request to the Ministry of Health on the e-SIC portal. Nominal data require ethical committee approval in most of the cases.\n\n\nUsing microdatasus\n\nMicrodatasus is an R package developed to download and preprocess data from the department of informatic of the Unified Health System (DATASUS). It can be installed and loaded with the following commands in R:\n\nif(!\"devtools\" %in% installed.packages()) { install.packages(\"devtools\") }\nlibrary(devtools)\nif(!\"microdatasus\" %in% installed.packages()){ devtools::install_github(\"rfsaldanha/microdatasus\") }\nlibrary(microdatasus)\n\nThe microdatasus package has two main functions: downloading data and pre-processing it. The function to download data is “fetch_datasus”, and one needs to specify:\n\nThe temporal extent of the data: via year_start, month_start, year_end and month_end.\nThe spatial extent: by specifying the federative units.\nThe disease: by selecting the health information system.\nThe variables: default is downloading every variable.\n\nHere a few examples:\nObservation: SINAN malaria has data for Extra-Amazon region.\n\nchik     &lt;-    fetch_datasus(year_start = 2017, year_end = 2019, information_system = \"SINAN-CHIKUNGUNYA\")\nmal      &lt;-    fetch_datasus(year_start = 2004, year_end = 2006, information_system = \"SINAN-MALARIA\")\nden      &lt;-    fetch_datasus(year_start = 2011, year_end = 2011, information_system = \"SINAN-DENGUE\")\nzika     &lt;-    fetch_datasus(year_start = 2016, year_end = 2021, information_system = \"SINAN-ZIKA\")\n\nThe second functionality of this package is to preprocess the datasets. This includes the following steps:\n\nAssigning labels to categorical fields, eg CS_RACA goes from (1,2,3,…) to (Branca (White), Preta (Black), Amarela (Yellow),…)\nConverts each variable to its correct format, eg. from factor to character.\nSimplifying the age variable by changing the NU_IDADE_N field into IDADEminutos, IDADEhoras, IDADEdias, IDADEmeses and IDADEanos.\n\nSince the datasets of all loaded diseases are different, the package has distinct function for all of them.\n\nchik2 &lt;- process_sinan_chikungunya(chik)\nmal2  &lt;- process_sinan_malaria(mal)\nden2  &lt;- process_sinan_dengue(den)\nzika2 &lt;- process_sinan_zika(zika)\n\n\n\n\nUsing Filezilla\n\nSINAN has File Transfer Protocol (FTP) link to download data directly. For this, it is necessary to use a FTP application like FileZilla.\nThe host link is ftp.datasus.gov.br and the remote site is /dissemin/publicos/SINAN/. Once the connection is established, the correct folder will appear on the screen. Inside of the “DADOS” folder, there are two folders: “FINAIS” and “PRELIM”. The “FINAIS” folder contains all the revised historical data, while “PRELIM” contains the non-revised raw data of the last year(s). Both are organized by disease and year. If a database is available on “FINAIS”, it means this is not available on “PRELIM”. \n\n\n\nUsing Datasus website + commandline\n\nThe Ministry of Health provides a website to search for and download files. Enter the page and fill in the following:\n\nSource (Fonte): SINAN - Sistema de Informaçoes de Agravos de Notificaçao\nModalidade: Dados\nTipo de Arquivo: Select the disease of your interest\nAno: Select your desired years\nUF: BR\n\nAnd then click on “enviar”. A list with all selected data files will appear. Clicking on the files, a pop up will appear asking you to choose which program should be used to open the link. If you have a FTP program which accepts FTP links with the filename in the url you can select it (FileZilla does not support this). Otherwise, you can right click on the file, copy the link address and go to the command line to write the following:\nwget ftp://ftp.datasus.gov.br/dissemin/publicos/SINAN/DADOS/PRELIM/DENGBR21.dbc -P Path/where/you/want/to/save/\n\n\n\nUsing PySUS package\n\nThe PySUS package was developed to directly download data from Python. The package can be downloaded using the following commands in the terminal:\n\nsudo apt install libffi-dev\nsudo pip install PySUS\npip install geocoder\n\nThen, a file path for the loaded data has to be established. The following can either be typed into the command line each time before or written into the ~/.bashrc file for a permanent setting.\n\nexport PYSUS_CACHEPATH=\"/home/me/desired/path/.pysus\"\n\nThen, within python, the data can be loaded and explored with the following lines of code.\n\nfrom pysus.preprocessing.sinan import SINAN\nSINAN.list_diseases()\nSINAN.get_available_years('zika')\ndf = SINAN.download(2019,'Zika')\n\nDownloaded files can be found as parquet files in the folder that was defined above. Further functions can be seen in the guide.\n\n\n\nHow to download other data\n\n\nShapefiles\n\n\n\nManually Download the data\nShapefiles with polygons of Brazilian regions, states, municipalities and other administrative levels can be downloaded directly from the geoftp from Brazil Institute for geography and Statistics (IBGE). In this link you can select the year, the region (or the whole country) and the spatial resolution (municipality/microregion, mesoregion, regions, Federal units, country) that you want to dowload as a zip file.\nAnother option is to use the IBGE directly IBGE \n\n\nLocal function\n\nlevel: (required) what administrative level, either municipality “muni” or “UF”\nyear: (required) Year of municipalities, starting from 2015\noutfile: The path and name of where you want to store it\nload: Should the population data be loaded into the environment? Default is TRUE\nsave: Should the population data be saved on the local disk? Default is TRUE\n\n\nget_br_adm_data(\"UF\", 2015, load=TRUE, save=FALSE)\nget_br_adm_data(\"UF\", 2020, \"Data/BR_muni.shp\", load=FALSE)\n\n\n\nGeobr package\nAdministrative shapefiles can also be loaded directly in R through the package geobr.\n\nif(!\"devtools\" %in% installed.packages()) { install.packages(\"devtools\") }\nlibrary(devtools)\nif(!\"geobr\" %in% installed.packages()){ install.packages(\"geobr\") }\nlibrary(geobr)\n\nmun &lt;- read_municipality(code_muni=\"all\", year=2018)\nmun &lt;- read_municipality(code_muni=\"RJ\", year=2010)\nmun &lt;- read_municipality(code_muni=1200179, year=2017)\n\nMunicipality codes have 6 numbers. The first number indicates the region of Brazil, the second number indicates the state, and the remaining 4 numbers indicate the municipality. If, like in the geobr dataset, the municipality code has 7 numbers, the last one needs to be excluded.\n\n\n\nPopulation Data\n\nPopulation estimates for each municipality can be downloaded from the IBGE (Brazilian Institute of Geography and Statistics). Here is the data for 2021. Earlier years can be downloaded from here. Alternatively, you can use the internal function below to select the desired year:\n\nyear: selected year(s) for which the population data should be downloaded (check available years first)\noutpath: Where should the population csv be saved? Only needed if “save” is TRUE\nload: Should the population data be loaded into the environment? Default is TRUE\nsave: Should the population data be saved on the local disk? Default is TRUE\n\n\nget_br_pop_data(2015, \"Data/Demographic/\")\nget_br_pop_data(2016, \"Data/Demographic/\", load=F)\nget_br_pop_data(2017, save=F)\nget_br_pop_data(c(2018,2019), save=F)\n\n\n\n\nAdministrative units inside Amazonia legal\n\nThe list of municipalities that lay within the legal amazonia can be downloaded from IBGE with the following internal function:\n\npercentage: (optional) What percentage of the municipality should be inside the amazonia legal for it to be included? (defaults to 50)\noutfile: How should the list of municipalities codes be named?\n\n\nget_amazon_adm(outfile=\"Data/AmazoniaLegal.csv\")\nget_amazon_adm(20, \"Data/AmazoniaLegal.csv\")",
    "crumbs": [
      "Brazil",
      "Download data"
    ]
  },
  {
    "objectID": "domrep_dengue.html",
    "href": "domrep_dengue.html",
    "title": "data4health",
    "section": "",
    "text": "domrep for dengue",
    "crumbs": [
      "Dominican Republic",
      "Dengue"
    ]
  },
  {
    "objectID": "brazil_report_public.html",
    "href": "brazil_report_public.html",
    "title": "General public report Brazil",
    "section": "",
    "text": "You can download this report  here",
    "crumbs": [
      "Brazil",
      "General public report"
    ]
  }
]